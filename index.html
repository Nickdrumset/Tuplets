<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nick Drum – Tuplets</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&amp;display=swap" rel="stylesheet">
  <style>
    :root{
      --bg1:#bcd9cc;   /* mint - darkened */
      --bg2:#ffc49c;   /* peach - darkened */
      --bg3:#b9d0f3;   /* soft blue - darkened */
      --card:#f4f4f4ee;
      --text:#1b262f;
      --muted:#495762;
      --accent:#088ca3;
      --ok:#279854;
      --warn:#a86c14;
      --tile:#ebeff5;
      --tile-on:#dae3f1;
      --tile-border:#d9e0eb;
      --grid:#e3e9f3;
      --shadow:0 8px 28px rgba(0,0,0,.18), 0 2px 6px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%}

    body {
      margin: 0;
      min-height: 100%;
      background:
        radial-gradient(1200px 800px at 0% 0%, var(--bg1) 0%, transparent 60%),
        radial-gradient(1200px 800px at 100% 20%, var(--bg2) 0%, transparent 55%),
        radial-gradient(1000px 700px at 75% 100%, var(--bg3) 0%, transparent 60%),
        #f6f8fb;
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      text-align: center;
    }

    /* Fit-to-screen scaling container */
    body{overflow:hidden;}
    .scale-viewport{
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px; /* 10px margin on all sides at max size */
    }
    #scale-content{
      transform-origin: center center; /* scale from center for perfect centering */
      will-change: transform;
    }

    #title {
      font-size: 24px;
      margin-bottom: 10px;
    }

    .slot img {
      width: 48px;
      height: 48px;
      object-fit: contain;
      margin: 0;
      border-radius: 0;
    }

    .row {
      display: flex;
      justify-content: center;
      margin-bottom: 8px;
      gap: 8px;
    }

    .slot {
      display: flex;
      gap: 0px;
      margin: 0;
    }

    .wrap{max-width:1000px;margin:24px auto;padding:16px}
    .hero{
      font-size: clamp(40px, 8vw, 92px);
      font-weight: 800;
      line-height: 1.05;
      margin: 8px 0 16px;
      color: transparent;
      -webkit-text-stroke: 2px rgba(255,255,255,0.85);
      text-shadow: 0 2px 4px rgba(0,0,0,0.25);
      letter-spacing: .5px;
    }
    .subtitle{
      font-size: 18px;
      color: var(--muted);
      margin-top: -4px;
    }

    .card{
      background: var(--card);
      border: 1px solid rgba(255,255,255,0.7);
      border-radius: 20px;
      box-shadow: var(--shadow);
      backdrop-filter: saturate(1.2) blur(4px);
    }
    .row{display:flex;gap:12px;flex-wrap:wrap}

    .controls{padding:20px;display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:14px;align-items:center}
    .controls label{font-size:12px;color:var(--muted);font-weight:600;letter-spacing:.2px}
    .controls .grp{display:flex;flex-direction:column;gap:8px;align-items:stretch}
    input[type=number]{background:#fff;border:1px solid var(--tile-border);color:var(--text);padding:12px 14px;border-radius:14px;font-size:16px;box-shadow:0 1px 0 rgba(0,0,0,.03) inset}
    select{background:#fff;border:1px solid var(--tile-border);color:var(--text);padding:12px 14px;border-radius:14px;font-size:16px}
    .btns{display:flex;gap:10px;align-items:center}
    button{cursor:pointer;border:1px solid #e7ebf2;background:#ffffff;color:var(--text);padding:12px 16px;border-radius:14px;font-weight:700;box-shadow:0 2px 0 rgba(0,0,0,.04)}
    button.primary{background:#f0fbff;border-color:#d4eef6}
    button.ok{background:#eefaf2;border-color:#d6efdf}
    button.warn{background:#fff6ea;border-color:#f3e2c7}
    button:disabled{opacity:.6;cursor:not-allowed}

    .status{display:none}

    .grid{margin-top:16px;padding:16px;border-top:1px solid #eef2f7}
    .grid h3{margin:0 0 10px;font-size:16px;color:#3a4b5a}

    .slots{
      display:flex;
      flex-direction:column;
      gap:16px;
      align-items:flex-start; /* left-align bars so 1st and 4th columns line up */
    }
    .bar{display:flex;gap:0px;margin-bottom:8px}
    .bar img {
      width: 288px; /* 1.5x wider than before */
      height: 88px; /* increased again (~10% more vertically) */
      background: var(--tile);
      border: 1px solid var(--tile-border);
      user-select: none;
      border-radius: 8px;
      transform-origin: center center;
      will-change: transform, box-shadow, background, border-color;
      transition:
        background 0.08s ease-out,
        border-color 0.08s ease-out;
    }

    .bar img.playing{
      background: var(--tile-on);
      border-color: var(--accent);
      animation: slotPulse 0.18s ease-out;
    }

    @keyframes slotPulse {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(14,165,183,0.0);
      }
      40% {
        transform: scale(1.03);
        box-shadow: 0 0 18px 2px rgba(14,165,183,0.35);
      }
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(14,165,183,0.0);
      }
    }


    .measure {
      display: flex;
      gap: 0;
      margin-right: 12px;
    }

    .legend{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px;color:var(--muted);font-size:12px}
    .legend span{display:inline-flex;align-items:center;gap:6px}
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.primary{background:var(--accent)}
    .dot.ok{background:var(--ok)}
    .dot.warn{background:var(--warn)}

    .footer{margin-top:18px;color:#7e8b97;font-size:12px}
    .kbd{background:#ffffff;border:1px solid #e7ebf2;border-bottom-width:3px;padding:2px 6px;border-radius:6px;box-shadow:0 1px 0 rgba(0,0,0,.03) inset}

    @media (max-width:480px){
      .hero{-webkit-text-stroke:1.5px}
    }
  </style>
</head>
<body>
  <div class="scale-viewport"><div class="wrap" id="scale-content">
    <div class="hero">Tuplets</div>

    <section class="card controls">
      <div class="grp">
        <label for="bpm">Start BPM</label>
        <input id="bpm" type="number" min="30" max="240" step="1" value="60"/>
      </div>
      <div class="grp">
        <label for="target">Target BPM (stop at)</label>
        <input id="target" type="number" min="40" max="300" step="1" value="130"/>
      </div>
      <div class="grp btns">
        <button id="start" class="primary">Start (Space)</button>
        <button id="stop" class="warn" disabled>Stop</button>
      </div>
      <div class="status" id="status"></div>
    </section>

    <section class="card grid">
      <h3>Pattern Slots</h3>
      <div class="slots" id="slots">
        <div class="bar">
          <div class="measure">
            <img src="Images/1.png" alt="tile 1" />
          </div>
          <div class="measure">
            <img src="Images/2.png" alt="tile 2" />
          </div>
          <div class="measure">
            <img src="Images/3.png" alt="tile 3" />
          </div>
        </div>
        <div class="bar">
          <div class="measure">
            <img src="Images/4.png" alt="tile 4" />
          </div>
          <div class="measure">
            <img src="Images/5.png" alt="tile 5" />
          </div>
        </div>
      </div>
    </section>

  </div></div>

  <script>
    // ====== Config ======
    const REPEATS_PER_TEMPO = 2;          // 패턴 2회 반복 후
    const TEMPO_INCREMENT = 10;           // BPM +10
    const REST_ONE_BAR = true;            // 1마디 휴식 활성화

    // ====== Pattern ======
    const beatPattern = [
      true,false,false,false,  true,false,false,false,
      true,false,false,false,  true,false,false,false
    ];
    // snare: each Pattern Slot == 1 beat
    // Sequence: (oxox) × 8  followed by  (oooo) × 4  => total 48 beats, loops thereafter
    const snarePattern = (() => {
      const seq = [];
      for (let i = 0; i < 8; i++) seq.push(true, false, true, false); // oxox
      for (let i = 0; i < 4; i++) seq.push(true, true, true, true);   // oooo
      return seq;
    })();
    const TOTAL_STEPS = beatPattern.length;

    // ====== Beat-subdivision Pattern (hits per beat) ======
    // We have 5 slots, each slot = 4 beats, so 20 beats total.
    // For each beat, we store how many snare hits should occur in that beat.
    // Slot-wise definition:
    //   Slot 1 (beats 1–4):  1 hit per beat (quarter notes)
    //   Slot 2 (beats 5–8):  2 hits per beat (2-division)
    //   Slot 3 (beats 9–12): 3 hits per beat (3-division)
    //   Slot 4 (beats 13–16):4 hits per beat (4-division)
    //   Slot 5 (beats 17–20):6 hits per beat (6-division)
    //
    // The actual timing of hits is evenly spaced within a beat.
    const beatSubdivisionPattern = [
      // Slot 1 (beats 1–4)
      1, 1, 1, 1,
      // Slot 2 (beats 5–8)
      2, 2, 2, 2,
      // Slot 3 (beats 9–12)
      3, 3, 3, 3,
      // Slot 4 (beats 13–16)
      4, 4, 4, 4,
      // Slot 5 (beats 17–20)
      6, 6, 6, 6
    ];

    // ====== State ======
    let bpm = 60;
    let targetBpm = 130;

    let isPlaying = false;
    let audioCtx = null;
    let nextNoteTime = 0;                 // WebAudio clock
    let currentBeatIndex = 0;             // 0..beatsPerBar-1
    let playedBarsThisTempo = 0;          // 현재 BPM에서 연주 완료한 마디 수
    let inRestBar = false;                // 휴식 마디 상태

    let preCountBeatsLeft = 0; // 예비박 카운트

    let schedulerId = null;               // setInterval 핸들
    let scheduledTimeouts = [];
    let currentHighlight = -1;

    // ====== Elements ======
    const elBpm = document.getElementById('bpm');
    const elTarget = document.getElementById('target');
    const elStart = document.getElementById('start');
    const elStop = document.getElementById('stop');
    const elStatus = document.getElementById('status');

    // ====== Elements ======
    const slotImgs = Array.from(document.querySelectorAll('#slots img'));

    function at(time, fn){
      const ctx = ensureAudio();
      const delay = Math.max(0, (time - ctx.currentTime) * 1000);
      const id = setTimeout(fn, delay);
      scheduledTimeouts.push(id);
      return id;
    }

    function highlightBeatIndex(idx, startAt, durSec){
      const groupIdx = Math.floor(idx / 4); // 4 beats per visual slot
      if(groupIdx < 0 || groupIdx >= slotImgs.length) return;
      at(startAt, ()=> {
        // remove previous highlight (if any)
        if(currentHighlight !== -1 && slotImgs[currentHighlight]){
          slotImgs[currentHighlight].classList.remove('playing');
        }
        // set new highlight
        currentHighlight = groupIdx;
        if(slotImgs[groupIdx]){
          slotImgs[groupIdx].classList.add('playing');
        }
      });
    }

    // ====== Audio (inline code generation) ======
    // Clave(우드 클릭) 사운드 생성기
    function ensureAudio(){
      if(!window.audioCtx){
        window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if(!window.masterGain){
        window.masterGain = window.audioCtx.createGain();
        window.masterGain.gain.setValueAtTime(1, window.audioCtx.currentTime);
        window.masterGain.connect(window.audioCtx.destination);
      }
      return window.audioCtx;
    }
    function claveSound(time, accent=false){
      const ctx = ensureAudio();
      // 짧은 스퀘어 톤 + 하이패스 = 목재 클릭 느낌
      const osc = ctx.createOscillator();
      const hp  = ctx.createBiquadFilter();
      const g   = ctx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(accent ? 2000 : 1700, time);
      hp.type = 'highpass';
      hp.frequency.setValueAtTime(1200, time);
      g.gain.setValueAtTime(accent ? 0.34 : 0.26, time);
      g.gain.exponentialRampToValueAtTime(0.0001, time + 0.045);
      osc.connect(hp).connect(g).connect(window.masterGain);
      osc.start(time);
      osc.stop(time + 0.05);
      // 트랜지언트 클릭(임펄스)을 아주 짧게 더해 목재 타격감을 강화
      const clickBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.004), ctx.sampleRate);
      const ch = clickBuf.getChannelData(0);
      ch[0] = 1.0; // 임펄스
      const clickSrc = ctx.createBufferSource();
      const gg = ctx.createGain();
      gg.gain.setValueAtTime(accent ? 0.32 : 0.24, time);
      gg.gain.exponentialRampToValueAtTime(0.0001, time + 0.01);
      clickSrc.buffer = clickBuf;
      clickSrc.connect(gg).connect(window.masterGain);
      clickSrc.start(time);
    }

    // 스네어(노이즈 버스트) 사운드
    function snareSound(time){
      const ctx = ensureAudio();
      // 화이트 노이즈 버퍼
      const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.18, ctx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < noiseBuffer.length; i++) data[i] = Math.random() * 2 - 1;
      const noise = ctx.createBufferSource();
      noise.buffer = noiseBuffer;
      // 하이패스 + 약간의 대역통과로 스네어 톤 만들기
      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass'; hp.frequency.setValueAtTime(1200, time);
      const bp = ctx.createBiquadFilter();
      bp.type = 'bandpass'; bp.frequency.setValueAtTime(2500, time); bp.Q.setValueAtTime(0.8, time);
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.6, time);
      g.gain.exponentialRampToValueAtTime(0.01, time + 0.12);
      noise.connect(hp).connect(bp).connect(g).connect(window.masterGain);
      noise.start(time);
      noise.stop(time + 0.18);
    }

    // 메트로놈 클릭 사운드
    function clickSound(time, accent=false){
      const ctx = ensureAudio();
      const osc = ctx.createOscillator();
      const g   = ctx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(accent ? 1500 : 1200, time);
      g.gain.setValueAtTime(accent ? 0.25 : 0.18, time);
      g.gain.exponentialRampToValueAtTime(0.0001, time + 0.04);
      osc.connect(g).connect(window.masterGain);
      osc.start(time);
      osc.stop(time + 0.05);
    }

    // 주어진 시작시간(startAt)부터 beatSubdivisionPattern을 1회 연주 (메트로놈 클릭 및 하이라이트 포함)
    function playPatternOnce(startAt, bpmCurrent){
      const secPerBeat = 60 / bpmCurrent;
      const barLen = 4; // fixed to 4/4 time
      for(let beatIdx = 0; beatIdx < beatSubdivisionPattern.length; beatIdx++){
        const hits = beatSubdivisionPattern[beatIdx] || 0; // number of snare hits in this beat
        const beatStart = startAt + beatIdx * secPerBeat;
        // 1) Beat click (accent on downbeat)
        clickSound(beatStart, (beatIdx % barLen) === 0);
        // 2) Highlight the matching slot image
        highlightBeatIndex(beatIdx, beatStart, secPerBeat);
        // 3) Subdivision snare hits: evenly divide the beat into 'hits' segments
        if(hits > 0){
          const interval = secPerBeat / hits;
          for(let h = 0; h < hits; h++){
            const t = beatStart + h * interval;
            snareSound(t);
          }
        }
      }
      return startAt + beatSubdivisionPattern.length * secPerBeat; // end time
    }

    // ====== Scheduler ======
    // 재생 로직 비활성화를 위해 스케줄러 더미화
    function nextBeat(){ /* disabled */ }
    function schedule(){ /* disabled */ }

    function start(){
      // 완전 초기화 후 시작
      stop();
      const ctx = ensureAudio();
      if(window.masterGain){
        window.masterGain.gain.cancelScheduledValues(ctx.currentTime);
        window.masterGain.gain.setValueAtTime(1, ctx.currentTime);
      }
      isPlaying = true;
      elStart.disabled = true;
      elStop.disabled = false;
    
      // 입력값
      bpm = clamp(parseInt(elBpm.value || 80, 10), 30, 240);
      elBpm.value = bpm;
      const target = clamp(parseInt(elTarget.value || 200, 10), 40, 300);
      elTarget.value = target;
    
      const secPerBeat = 60 / bpm;
      const t0 = ctx.currentTime + 0.05; // 소량 여유
    
      // 최초 1회만 프리카운트 4클릭
      for(let i=0;i<4;i++){
        claveSound(t0 + i * secPerBeat, i === 0);
      }
    
      // 프리카운트 직후부터 체인 재생 시작
      const firstStart = t0 + 4 * secPerBeat;
      at(firstStart - 0.001, ()=> playCycleChain(firstStart, bpm, target, false));
    }

    // Helper: strictly compute next BPM once per cycle
    function getNextBpm(prevBpm, target){
      return Math.min(target, prevBpm + TEMPO_INCREMENT);
    }

    // Helper: schedule a 4-beat count-in (clave) and return the time right after it
    function scheduleCountIn(startAt, bpmCurrent){
      const ctx = ensureAudio();
      const secPerBeat = 60 / bpmCurrent;
      for(let i=0;i<4;i++){
        claveSound(startAt + i * secPerBeat, i === 0);
      }
      return startAt + 4 * secPerBeat;
    }

    // 패턴을 +10 BPM씩 타겟까지 체인 재생 (+10 1회 고정, 사이클 사이 4비트 카운트인)
    function playCycleChain(startAt, bpmCurrent, targetBpm, withCountIn=false){
      if(!isPlaying) return; // 사용자가 중단한 경우

      const ctx = ensureAudio();
      let t = startAt;

      // 요청사항: 다음 속도로 넘어갈 때마다 4비트 클릭(카운트인) 후 slots 재생
      if(withCountIn){
        t = scheduleCountIn(t, bpmCurrent);
      }

      // 현재 템포에서 slots 패턴 1회 재생
      const endAt = playPatternOnce(t, bpmCurrent);

      // 타겟 도달 시: 마지막 사이클 후 자동 정지
      if(bpmCurrent >= targetBpm){
        at(endAt + 0.01, ()=> stop());
        return;
      }

      // 다음 템포 계산: +10(고정), 타겟 초과 방지
      const nextBpm = getNextBpm(bpmCurrent, targetBpm);

      // 다음 사이클 시작 시간 예약(오디오 시계 기준)
      const nextStart = Math.max(endAt + 0.02, ctx.currentTime + 0.02);

      // 다음 사이클은 카운트인을 포함하여 실행
      // *주의*: BPM 표시 업데이트는 실제 다음 사이클이 시작할 때 수행하여
      // 시작 직후에 템포가 올라간 것처럼 보이는 현상을 방지
      at(nextStart, ()=> {
        elBpm.value = nextBpm;           // UI는 다음 사이클 시작 시점에 반영
        playCycleChain(nextStart, nextBpm, targetBpm, true);
      });
    }

    function stop(){
      // 1) Cancel any scheduled UI callbacks (highlights, completion handlers)
      scheduledTimeouts.forEach(id => clearTimeout(id));
      scheduledTimeouts = [];
      // remove any active highlight immediately
      if(currentHighlight !== -1 && slotImgs[currentHighlight]){
        slotImgs[currentHighlight].classList.remove('playing');
        currentHighlight = -1;
      }
      // 2) HARD STOP: disconnect master and close/suspend AudioContext so no further scheduled audio can fire
      try{
        if(window.masterGain){
          try{ window.masterGain.disconnect(); }catch(e){}
          window.masterGain = null;
        }
        if(window.audioCtx){
          const ctx = window.audioCtx;
          // best effort: close; if fails (e.g., due to state), fallback to suspend
          if(typeof ctx.close === 'function'){
            ctx.close().catch(()=>{ try{ ctx.suspend && ctx.suspend(); }catch(e){} });
          } else if (typeof ctx.suspend === 'function'){
            ctx.suspend();
          }
        }
      } finally {
        window.audioCtx = null; // force re-create on next start()
      }
      // 3) Reset UI state
      isPlaying = false;
      elStart.disabled = false;
      elStop.disabled = true;
      setStatus('정지됨.');
    }
    function toggleFullscreen(){
      const el = document.documentElement;
      if(!document.fullscreenElement){
        if(el.requestFullscreen) el.requestFullscreen().then(()=>setTimeout(fitScale, 50));
      } else {
        if(document.exitFullscreen) document.exitFullscreen().then(()=>setTimeout(fitScale, 50));
      }
    }


    function setStatus(msg){ /* status UI disabled */ }
    function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }

    // ====== Fit to Screen (keep within viewport on resize) ======
    function fitScale(){
      const content = document.getElementById('scale-content');
      if(!content) return;
      // reset transform to measure natural size
      content.style.transform = 'none';
      // Allow layout to settle before measurement in some browsers
      const rect = content.getBoundingClientRect();
      const vpW = Math.max(1, window.innerWidth - 20);  // 10px left + 10px right
      const vpH = Math.max(1, window.innerHeight - 20); // 10px top + 10px bottom
      const scale = Math.min(vpW / rect.width, vpH / rect.height);
      content.style.transform = `scale(${scale})`;
    }
    window.addEventListener('resize', fitScale);
    window.addEventListener('orientationchange', fitScale);
    document.addEventListener('fullscreenchange', fitScale);

    // ====== Events ======
    elStart.addEventListener('click', start);
    elStop.addEventListener('click', stop);


    window.addEventListener('keydown', (e)=>{
      if(e.key === ' '){
        e.preventDefault();
        isPlaying ? stop() : start();
      } else if(e.key === 'Escape'){
        // optional: exit fullscreen on Esc is handled by browser
      } else if(e.key === 'ArrowUp'){
        bpm = clamp(bpm + 10, 30, 240);
        elBpm.value = bpm; setStatus(`BPM ${bpm}`);
      } else if(e.key === 'ArrowDown'){
        bpm = clamp(bpm - 10, 30, 240);
        elBpm.value = bpm; setStatus(`BPM ${bpm}`);
      } else if(e.key === 'f' || e.key === 'F'){
        toggleFullscreen();
      }
    });

    // ====== Init ======
    // initial fit
    fitScale();

    // ====== Notes ======
    // - 사운드는 외부 WAV 파일 대신 코드 기반으로 생성됩니다.
    // - 타일 이미지는 프로젝트 루트의 Images 폴더(Images/1.png ~)에서 자동으로 로드됩니다.
    // - 패턴은 고정된 이미지 배열로 DOM에 직접 삽입되어 있습니다.
    // - 재생 시 'oxox oxox ... oooo' 구조를 JS에서 고정값으로 연주할 수 있도록 준비 중입니다.
  </script>
</body>
</html>
